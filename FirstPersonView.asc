
void CellViewSchema::SetView(int width, int height, int row_count, int col_count) {
	row_count = Maths.Min(row_count, CELLVIEW_MAX_CELL_ROWS);
	col_count = Maths.Min(col_count, CELLVIEW_MAX_CELL_COLS);

	Width = width;
	Height = height;
	CellRowCount = row_count;
	CellColCount = col_count;
	CellColMiddle = CellColCount / 2;
	VxRowCount = row_count + 1;
	VxColCount = col_count + 1;
}

void CellViewSchema::SetUniformStrip(int row, int y1, int y2, int x_start, int u_width) {
	if (row < 0 || row >= VxRowCount) {
		return;
	}

	Strips[row].Y1 = y1;
	Strips[row].Y2 = y2;
	for (int col = 0; col < VxColCount; ++col) {
		Strips[row].X[col] = x_start + u_width * col;
	}
}

void CellViewSchema::SetScaling(float base_scale, float row_scale, float col_scale) {
	float BaseScale = base_scale;
	float RowScaling = row_scale;
	float ColScaling = col_scale;

	float this_row_scale = base_scale;
	for (int row = 0; row < CellRowCount; ++row) {
		float this_col_sale = this_row_scale;
		CellScaling[row, CellColMiddle] = this_col_sale;
		for (int col = 0; col < CellColMiddle; ++col) {
			this_col_sale *= col_scale;
			CellScaling[row, CellColMiddle - col] = this_col_sale;
			CellScaling[row, CellColMiddle + col] = this_col_sale;
		}
		this_row_scale *= row_scale;
	}
}

Point *CellViewSchema::ObjectToCellView(int objx, int objy) {
	Point *cvpt = new Point;
	cvpt.x = objx + CV_Schema.CellColMiddle;
	cvpt.y = objy;
	return cvpt;
}

CellViewSchema CV_Schema;
export CV_Schema;


// internal data
struct FirstPersonViewData {
	// Camera offsets to use when constructing the scene using overlays
	int CameraX;
	int CameraY;
	// Tells to draw walls half-height
	bool HalfWallMode;
	// Cell Walls per row, per col, per tile type
	// +1 extra cell row, because we draw front walls of the far row
	DynamicSprite *SprWalls[CELLVIEW_MAX_CELL_ROWS + 1, CELLVIEW_MAX_CELL_COLS, eCVTileNum];
	Overlay *OverWalls[CELLVIEW_MAX_CELL_ROWS + 1, CELLVIEW_MAX_CELL_COLS, eCVTileNum];
	// Relative z-order for each tile type
	int TileZorders[eCVTileNum];
};

FirstPersonViewData FPV;


protected static void FirstPersonView::ResetTileCache() {
	for (int x = 0; x < CELLVIEW_MAX_CELL_ROWS + 1; ++x) {
		for (int y = 0; y < CELLVIEW_MAX_CELL_COLS; ++y) {
			for (int t = 0; t < eCVTileNum; ++t) {
				FPV.OverWalls[x, y, t] = null;
				FPV.SprWalls[x, y, t] = null;
			}
		}
	}
}

static void FirstPersonView::SetHalfWallMode(bool half_wall) {
	FPV.HalfWallMode = half_wall;
	FirstPersonView.ResetTileCache();
}

static void FirstPersonView::DrawViewport(DrawingSurface* ds, int color) {
	ds.DrawingColor = color;
	ds.DrawFrame(0, 0, CV_Schema.Width - 1, CV_Schema.Height - 1);
}

static void FirstPersonView::DrawGridFrame(DrawingSurface* ds, int cell_color, int wall_color) {
	if (cell_color > 0) {
		ds.DrawingColor = cell_color;
		// NOTE: we assume that row 0 is "behind" the player's back, so invisible
		// horizontal lines (cells fronts)
		for (int row = 1; row < CV_Schema.VxRowCount; ++row) {
			for (int col = 0; col < CV_Schema.VxColCount - 1; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row].X[col + 1], 
							CV_Schema.Strips[row].Y1);
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2, 
							CV_Schema.Strips[row].X[col + 1], 
							CV_Schema.Strips[row].Y2);
			}
		}
		
		// directional lines (cell sides)
		for (int row = 0; row < CV_Schema.VxRowCount - 1; ++row) {
			for (int col = 0; col < CV_Schema.VxColCount; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row + 1].X[col], 
							CV_Schema.Strips[row + 1].Y1);
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2, 
							CV_Schema.Strips[row + 1].X[col], 
							CV_Schema.Strips[row + 1].Y2);
			}
		}
	}
	
	if (wall_color > 0) {
		ds.DrawingColor = wall_color;
		for (int row = 0; row < CV_Schema.VxRowCount; ++row) {
			for (int col = 0; col < CV_Schema.VxColCount; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2);
			}
		}
	}
}

// Draws current view as seen from the given cell into given direction
// TODO: for optimization, we might keep record of which cell views are "clean"
// and which are "dirty" and only redraw latter.
static void FirstPersonView::DrawLocation(DrawingSurface *ds, ObjectPosition *eye) {
	if (CV_Schema.CellRowCount == 0 || CV_Schema.CellColCount == 0) {
		return;
	}

	// +1 extra cell row, because we draw front walls of the far row
	readonly int num_rows = CV_Schema.CellRowCount + 1;
	readonly int num_cols = CV_Schema.CellColCount;
	readonly int mid = CV_Schema.CellColMiddle;

	// Prepare the transform axes.
	MapTransform *t = Level.GetObjectToMapTransform(eye);
	// Look around the map cells and draw what can be seen;
	// we start from the further row and come closer, far sides first.
	for (int row = num_rows - 1; row >= 0; --row) {
		// Draw columns in following order: first side columns from left and
		// right coming to the middle step by step, and then finally the middle one.
		for (int col = 0; col < mid; col++) {
			FirstPersonView.DrawCell(ds, eye,
				t.originX + row * t.viewRowAxisX + (col - mid) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (col - mid) * t.viewColAxisY,
				row, col);
			FirstPersonView.DrawCell(ds, eye,
				t.originX + row * t.viewRowAxisX + (mid - col) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (mid - col) * t.viewColAxisY,
				row, num_cols - col - 1);
		}
		FirstPersonView.DrawCell(ds, eye,
			t.originX + row * t.viewRowAxisX + 0 * t.viewColAxisX,
			t.originY + row * t.viewRowAxisY + 0 * t.viewColAxisY,
			row, mid);
	}
}

// Draws particular map cell in viewport
static void FirstPersonView::DrawCell(DrawingSurface *ds, ObjectPosition *eye,
									  int mapx, int mapy, int row, int col) {
	if (mapx < 0 || mapx >= CLevel.MapWidth || mapy < 0 || mapy >= CLevel.MapHeight) {
		return;
	}
	// +1 extra cell row, because we draw front walls of the far row
	if (row < 0 || row >= CV_Schema.CellRowCount + 1 ||
		col < 0 || col >= CV_Schema.CellColCount) {
		return;
	}
	
	int color_wall_1 = CLevel.BasicColor1;
	int color_wall_2 = CLevel.BasicColor2;
	
	char type = CLevel.CellPassable[mapy * CLevel.MapWidth + mapx];
	if (type == 0) {
		// Draw floor and ceiling
		// --- skip for now ---
	} else {
		// Draw cell walls
		// cell lies in between the frame lines, so convert to vertex row/cols
		int frame_front_row = row;
		int frame_back_row = row + 1;
		int frame_left_col = col;
		int frame_right_col = col + 1;

		int front_x1 = CV_Schema.Strips[frame_front_row].X[frame_left_col];
		int front_x2 = CV_Schema.Strips[frame_front_row].X[frame_right_col];
		int front_y1 = CV_Schema.Strips[frame_front_row].Y1;
		int front_y2 = CV_Schema.Strips[frame_front_row].Y2;
		
		// Draw front wall, unless it's a base row
		if (row != 0) {
			ds.DrawQuadSplit(
				front_x1, front_y1, front_x2, front_y1,
				front_x2, front_y2, front_x1, front_y2, 
				color_wall_1, color_wall_2);
		}
		
		// Far row: only draw front wall, skip sides
		if (row == CV_Schema.CellRowCount) {
			return;
		}
		
		if (col < CV_Schema.CellColMiddle) {
			// Draw right wall
			int side_x1 = front_x2;
			int side_x2 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
			int side_y11 = front_y1;
			int side_y12 = front_y2;
			int side_y21 = CV_Schema.Strips[frame_back_row].Y1;
			int side_y22 = CV_Schema.Strips[frame_back_row].Y2;
			ds.DrawQuadSplit(
				side_x1, side_y11, side_x2, side_y21,
				side_x2, side_y22, side_x1, side_y12, 
				color_wall_1, color_wall_2);
		} else if (col > CV_Schema.CellColMiddle) {
			// Draw left wall
			int side_x1 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
			int side_x2 = front_x1;
			int side_y11 = CV_Schema.Strips[frame_back_row].Y1;
			int side_y12 = CV_Schema.Strips[frame_back_row].Y2;
			int side_y21 = front_y1;
			int side_y22 = front_y2;
			ds.DrawQuadSplit(
				side_x1, side_y11, side_x2, side_y21,
				side_x2, side_y22, side_x1, side_y12, 
				color_wall_1, color_wall_2);
		}
	}
}

static void FirstPersonView::SetCameraOffset(int camx, int camy) {
	FPV.CameraX = camx;
	FPV.CameraY = camy;
}

static void FirstPersonView::ConstructLocation(ObjectPosition *eye) {
	if (CV_Schema.CellRowCount == 0 || CV_Schema.CellColCount == 0) {
		return;
	}

	// +1 extra cell row, because we draw front walls of the far row
	readonly int num_rows = CV_Schema.CellRowCount + 1;
	readonly int num_cols = CV_Schema.CellColCount;
	readonly int mid = CV_Schema.CellColMiddle;

	// Prepare the transform axes.
	MapTransform *t = Level.GetObjectToMapTransform(eye);
	// Look around the map cells and draw what can be seen;
	// we start from the further row and come closer, far sides first.
	for (int row = num_rows - 1; row >= 0; --row) {
		// Draw columns in following order: first side columns from left and
		// right coming to the middle step by step, and then finally the middle one.
		for (int col = 0; col < mid; col++) {
			//System.Log(eLogDebug, "ConstructLocation: row %d col %d (%d)", row, col, num_cols - col - 1);
			FirstPersonView.ConstructCell(eye,
				t.originX + row * t.viewRowAxisX + (col - mid) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (col - mid) * t.viewColAxisY,
				row, col);
			FirstPersonView.ConstructCell(eye,
				t.originX + row * t.viewRowAxisX + (mid - col) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (mid - col) * t.viewColAxisY,
				row, num_cols - col - 1);
		}
		//System.Log(eLogDebug, "ConstructLocation: row %d col %d", row, mid);
		FirstPersonView.ConstructCell(eye,
			t.originX + row * t.viewRowAxisX + 0 * t.viewColAxisX,
			t.originY + row * t.viewRowAxisY + 0 * t.viewColAxisY,
			row, mid);
	}
}

static void FirstPersonView::ConstructCell(ObjectPosition *eye,
			int mapx, int mapy, int row, int col) {
	if (mapx < 0 || mapx >= CLevel.MapWidth || mapy < 0 || mapy >= CLevel.MapHeight) {
		return;
	}
	// +1 extra cell row, because we draw front walls of the far row
	if (row < 0 || row >= CV_Schema.CellRowCount + 1 ||
		col < 0 || col >= CV_Schema.CellColCount) {
		return;
	}
	
	char type = CLevel.CellPassable[mapy * CLevel.MapWidth + mapx];
	if (type == 0) {
		// Draw floor and ceiling
		// --- skip for now ---
		// Hide walls
		FirstPersonView.HideWallTile(row, col, eCVTile_Front);
		FirstPersonView.HideWallTile(row, col, eCVTile_Side);
	} else {
		// Draw cell walls
		// Draw front wall, unless it's a base row
		if (row != 0) {
			FirstPersonView.DisplayWallTile(row, col, eCVTile_Front);
		}
		// Draw side wall, unless it's a far row, or middle columns
		if (row != CV_Schema.CellRowCount && col != CV_Schema.CellColMiddle) {
			FirstPersonView.DisplayWallTile(row, col, eCVTile_Side);
		}
	}
}

protected static void FirstPersonView::CreateWallSprite(int row, int col, CellViewTile tile) {
	readonly bool is_right_wall = col < CV_Schema.CellColMiddle;
	
	// Calculate wall quad from the cell position
	int frame_front_row = row;
	int frame_back_row = row + 1;
	int frame_left_col = col;
	int frame_right_col = col + 1;
	int front_x1 = CV_Schema.Strips[frame_front_row].X[frame_left_col];
	int front_x2 = CV_Schema.Strips[frame_front_row].X[frame_right_col];
	int front_y1 = CV_Schema.Strips[frame_front_row].Y1;
	int front_y2 = CV_Schema.Strips[frame_front_row].Y2;
	
	int x1, x2, y11, y12, y21, y22;
	switch (tile) {
	case eCVTile_Floor: break; // TODO
	case eCVTile_Ceil: break; // TODO
	case eCVTile_Front:
		x1 = front_x1;
		x2 = front_x2;
		y11 = front_y1;
		y21 = front_y1;
		y12 = front_y2;
		y22 = front_y2;
		break;
	case eCVTile_Side:
		if (is_right_wall) {
			x1 = front_x2;
			x2 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
			y11 = front_y1;
			y12 = front_y2;
			y21 = CV_Schema.Strips[frame_back_row].Y1;
			y22 = CV_Schema.Strips[frame_back_row].Y2;
		} else {
			x1 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
			x2 = front_x1;
			y11 = CV_Schema.Strips[frame_back_row].Y1;
			y12 = CV_Schema.Strips[frame_back_row].Y2;
			y21 = front_y1;
			y22 = front_y2;
		}
		break;
	default: break;
	}

	if (FPV.HalfWallMode) {
		y11 = y11 + (y12 - y11) / 2;
		y21 = y21 + (y22 - y21) / 2;
	}
	
	int y_min = Maths.Min(y11, y21);
	DynamicSprite *dspr = DynamicSprite.Create(x2 - x1, Maths.Max(y12 - y11, y22 - y21));
	DrawingSurface *ds = dspr.GetDrawingSurface();
	ds.DrawQuadSplit(
				0, y11 - y_min, x2 - x1, y21 - y_min,
				x2 - x1, y22 - y_min, 0, y12 - y_min, 
				CLevel.BasicColor1, CLevel.BasicColor2);
	ds.Release();
	FPV.SprWalls[row, col, tile] = dspr;
}

protected static void FirstPersonView::CreateWallTile(int row, int col, CellViewTile tile) {
	if (FPV.SprWalls[row, col, tile] == null) {
		FirstPersonView.CreateWallSprite(row, col, tile);
	}
	
	readonly bool is_right_wall = col < CV_Schema.CellColMiddle;
	
	int x, y;
	switch (tile) {
	case eCVTile_Floor: break; // TODO
	case eCVTile_Ceil: break; // TODO
	case eCVTile_Front:
		x = CV_Schema.Strips[row].X[col];
		y = CV_Schema.Strips[row].Y1;
		break;
	case eCVTile_Side:
		if (is_right_wall) {
			x = CV_Schema.Strips[row].X[col + 1];
			y = CV_Schema.Strips[row].Y1;
		} else {
			x = CV_Schema.Strips[row + 1].X[col];
			y = CV_Schema.Strips[row].Y1;
		}
		break;
	default: break;
	}
	
	DynamicSprite *dspr = FPV.SprWalls[row, col, tile];
	if (FPV.HalfWallMode) {
		y += Game.SpriteHeight[dspr.Graphic];
	}
	Overlay *new_over = Overlay.CreateRoomGraphical(FPV.CameraX + x, FPV.CameraY + y, dspr.Graphic);
	new_over.ZOrder = FirstPersonView.CalcZorder(row, col, eCVTile_Object);
	FPV.OverWalls[row, col, tile] = new_over;
}

protected static void FirstPersonView::DisplayWallTile(int row, int col, CellViewTile tile) {
	if (FPV.OverWalls[row, col, tile] == null) {
		FirstPersonView.CreateWallTile(row, col, tile);	
	}
	
	Overlay *wall = FPV.OverWalls[row, col, tile];
	wall.Transparency = 0;
}

protected static void FirstPersonView::HideWallTile(int row, int col, CellViewTile tile) {
	Overlay *wall = FPV.OverWalls[row, col, tile];
	if (wall != null) {
		wall.Transparency = 100;
	}
}

static void FirstPersonView::ConstructObject(ObjectPosition *eye, ObjectPosition *obj, 
		int view, int loop, int frame, Overlay *over) {

	// First convert absolute object's coordinates into the player view's
	// coordinates. This is done through 2 transformations:
	// * map         -> player's local space (relative to player)
	// * local space -> cell view space (view row/col values)
	Point objlocpt = CLevel.MapToObject(eye, obj.X, obj.Y);
	Point cvpt = CV_Schema.ObjectToCellView(objlocpt.x, objlocpt.y);
	int col = cvpt.x;
	int row = cvpt.y;
	//
	//System.Log(eLogDebug, "ConstructObject: local to cellview: obj = %d,%d", 
	//	col, row);
	if (row < 0 || row >= CV_Schema.CellRowCount ||
		col < 0 || col >= CV_Schema.CellColCount) {
		// not in visible range
		//System.Log(eLogDebug, "ConstructObject: not in visible range");
		over.Transparency = 100;
		return;
	}

	// Object is located in the middle of a cell, in between the grid lines
	int frame_front_row = row;
	int frame_back_row = row + 1;
	int frame_left_col = col;
	int frame_right_col = col + 1;
	
	//System.Log(eLogDebug, "ConstructObject: frame lines: front %d,%d -> back %d,%d", 
	//	frame_front_row, frame_back_row, frame_left_col, frame_right_col);
	
	// Now when we know that we're going to place it on screen, let's set up a
	// proper graphic. Calculate which loop to use, depending on the RELATIVE
	// direction of the object's facing.
	ObjectDirection rel_dir = Level.MapToObjectDir(eye, obj.Dir);
	int use_loop = Level.DirToAGSLoop(rel_dir);
	//System.Log(eLogDebug, "ConstructObject: eyedir = %d, objdir = %d, rel_dir = %d, agsloop = %d", eye.Dir, obj.Dir, rel_dir, use_loop);
	ViewFrame *vf = Game.GetViewFrame(view, use_loop, frame);
	if (over.Graphic != vf.Graphic) {
		over.Graphic = vf.Graphic;
	}
	
	int y1 = CV_Schema.Strips[frame_back_row].Y2;
	int y2 = CV_Schema.Strips[frame_front_row].Y2;
	int x11 = CV_Schema.Strips[frame_front_row].X[frame_left_col];
	int x12 = CV_Schema.Strips[frame_front_row].X[frame_right_col];
	int x21 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
	int x22 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
	int x1 = (x11 + x12) / 2;
	int x2 = (x21 + x22) / 2;
	//System.Log(eLogDebug, "ConstructObject: x1,x2 = %d,%d", x1, x2);
	
	//System.Log(eLogDebug, "ConstructObject: pre scale w,h = %d,%d", over.Width, over.Height);
	float scaling = CV_Schema.CellScaling[row, col];
	over.Width = FloatToInt(IntToFloat(over.GraphicWidth) * scaling);
	over.Height = FloatToInt(IntToFloat(over.GraphicHeight) * scaling);
	//System.Log(eLogDebug, "ConstructObject: scaling = %f, w,h = %d,%d", scaling, over.Width, over.Height);
	int x = (x1 + x2) / 2 + FPV.CameraX - over.Width / 2;
	int y = (y1 + y2) / 2 + FPV.CameraY - over.Height;
	over.X = x;
	over.Y = y;
	over.ZOrder = FirstPersonView.CalcZorder(row, col, eCVTile_Object);
	over.Transparency = 0;
}

protected static int FirstPersonView::CalcZorder(int row, int col, CellViewTile tile) {
	int mid = CV_Schema.CellColMiddle;
	// z-order is increasing from far sides to the front center
	int effective_col = col <= mid ? col : (mid - (col - mid));
	// +1 extra cell row, because we draw front walls of the far row
	return ((CV_Schema.CellRowCount + 1 - row) * mid + effective_col) * eCVTileNum
		+ FPV.TileZorders[tile];
}


function game_start() {
	FPV.TileZorders[eCVTile_Floor]	= 0;
	FPV.TileZorders[eCVTile_Ceil]	= 1;
	FPV.TileZorders[eCVTile_Object]	= 2;
	FPV.TileZorders[eCVTile_Side]	= 3;
	FPV.TileZorders[eCVTile_Front]	= 4;
}
