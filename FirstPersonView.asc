
void CellViewSchema::SetView(int width, int height, int row_count, int col_count) {
	row_count = Maths.Min(row_count, CELLVIEW_MAX_CELL_ROWS);
	col_count = Maths.Min(col_count, CELLVIEW_MAX_CELL_COLS);

	Width = width;
	Height = height;
	CellRowCount = row_count;
	CellColCount = col_count;
	CellColMiddle = CellColCount / 2;
	VxRowCount = row_count + 1;
	VxColCount = col_count + 1;
}

void CellViewSchema::SetUniformStrip(int row, int y1, int y2, int x_start, int u_width) {
	if (row < 0 || row >= VxRowCount) {
		return;
	}

	Strips[row].Y1 = y1;
	Strips[row].Y2 = y2;
	for (int col = 0; col < VxColCount; ++col) {
		Strips[row].X[col] = x_start + u_width * col;
	}
}

void CellViewSchema::SetScaling(float base_scale, float row_scale, float col_scale) {
	float BaseScale = base_scale;
	float RowScaling = row_scale;
	float ColScaling = col_scale;

	float this_row_scale = base_scale;
	for (int row = 0; row < CellRowCount; ++row) {
		float this_col_sale = this_row_scale;
		CellScaling[row, CellColMiddle] = this_col_sale;
		for (int col = 0; col < CellColMiddle; ++col) {
			this_col_sale *= col_scale;
			CellScaling[row, CellColMiddle - col] = this_col_sale;
			CellScaling[row, CellColMiddle + col] = this_col_sale;
		}
		this_row_scale *= row_scale;
	}
}

Point *CellViewSchema::ObjectToCellView(int objx, int objy) {
	Point *cvpt = new Point;
	cvpt.x = objx + CV_Schema.CellColMiddle;
	cvpt.y = objy;
	return cvpt;
}

CellViewSchema CV_Schema;
export CV_Schema;

// DynamicSprites for generated (colored) textures
managed struct TileTextures {
	DynamicSprite *Base;
	DynamicSprite *Textures[];
};

// Contains overlay and cached references to the applied texture
managed struct WallTile {
	Overlay *Over;
	int TexID; // assigned texture ID
	// base position in the scene, necessary reference for any
	// adjustments because of shorter textures, etc
	int BaseX;
	int BaseY;
};

// internal data
struct FirstPersonViewData {
	// Camera offsets to use when constructing the scene using overlays
	int CameraX;
	int CameraY;
	// Tells to draw walls half-height
	bool HalfWallMode;
	// Cell Walls per row, per col, per tile type
	// +1 extra cell row, because we draw front walls of the far row
	TileTextures SprWalls[CELLVIEW_MAX_CELL_ROWS + 1, CELLVIEW_MAX_CELL_COLS, eCVTileNum];
	WallTile OverWalls[CELLVIEW_MAX_CELL_ROWS + 1, CELLVIEW_MAX_CELL_COLS, eCVTileNum];
	// Relative z-order for each tile type
	int TileZorders[eCVTileNum];
};

FirstPersonViewData FPV;


protected static void FirstPersonView::ResetTileCache() {
	// +1 extra cell row, because we draw front walls of the far row
	for (int x = 0; x < CELLVIEW_MAX_CELL_ROWS + 1; ++x) {
		for (int y = 0; y < CELLVIEW_MAX_CELL_COLS; ++y) {
			for (int t = 0; t < eCVTileNum; ++t) {
				FPV.OverWalls[x, y, t] = null;
				FPV.SprWalls[x, y, t] = null;
			}
		}
	}
}

static void FirstPersonView::SetHalfWallMode(bool half_wall) {
	FPV.HalfWallMode = half_wall;
}

static void FirstPersonView::DrawViewport(DrawingSurface* ds, int color) {
	ds.DrawingColor = color;
	ds.DrawFrame(0, 0, CV_Schema.Width - 1, CV_Schema.Height - 1);
}

static void FirstPersonView::DrawGridFrame(DrawingSurface* ds, int cell_color, int wall_color) {
	if (cell_color > 0) {
		ds.DrawingColor = cell_color;
		// NOTE: we assume that row 0 is "behind" the player's back, so invisible
		// horizontal lines (cells fronts)
		for (int row = 1; row < CV_Schema.VxRowCount; ++row) {
			for (int col = 0; col < CV_Schema.VxColCount - 1; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row].X[col + 1], 
							CV_Schema.Strips[row].Y1);
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2, 
							CV_Schema.Strips[row].X[col + 1], 
							CV_Schema.Strips[row].Y2);
			}
		}
		
		// directional lines (cell sides)
		for (int row = 0; row < CV_Schema.VxRowCount - 1; ++row) {
			for (int col = 0; col < CV_Schema.VxColCount; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row + 1].X[col], 
							CV_Schema.Strips[row + 1].Y1);
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2, 
							CV_Schema.Strips[row + 1].X[col], 
							CV_Schema.Strips[row + 1].Y2);
			}
		}
	}
	
	if (wall_color > 0) {
		ds.DrawingColor = wall_color;
		for (int row = 0; row < CV_Schema.VxRowCount; ++row) {
			for (int col = 0; col < CV_Schema.VxColCount; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2);
			}
		}
	}
}

// Draws current view as seen from the given cell into given direction
// TODO: for optimization, we might keep record of which cell views are "clean"
// and which are "dirty" and only redraw latter.
static void FirstPersonView::DrawLocation(DrawingSurface *ds, ObjectPosition *eye) {
	if (CV_Schema.CellRowCount == 0 || CV_Schema.CellColCount == 0) {
		return;
	}

	// +1 extra cell row, because we draw front walls of the far row
	readonly int num_rows = CV_Schema.CellRowCount + 1;
	readonly int num_cols = CV_Schema.CellColCount;
	readonly int mid = CV_Schema.CellColMiddle;

	// Prepare the transform axes.
	MapTransform *t = Level.GetObjectToMapTransform(eye);
	// Look around the map cells and draw what can be seen;
	// we start from the further row and come closer, far sides first.
	for (int row = num_rows - 1; row >= 0; --row) {
		// Draw columns in following order: first side columns from left and
		// right coming to the middle step by step, and then finally the middle one.
		for (int col = 0; col < mid; col++) {
			FirstPersonView.DrawCell(ds, eye,
				t.originX + row * t.viewRowAxisX + (col - mid) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (col - mid) * t.viewColAxisY,
				row, col);
			FirstPersonView.DrawCell(ds, eye,
				t.originX + row * t.viewRowAxisX + (mid - col) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (mid - col) * t.viewColAxisY,
				row, num_cols - col - 1);
		}
		FirstPersonView.DrawCell(ds, eye,
			t.originX + row * t.viewRowAxisX + 0 * t.viewColAxisX,
			t.originY + row * t.viewRowAxisY + 0 * t.viewColAxisY,
			row, mid);
	}
}

// Draws particular map cell in viewport
static void FirstPersonView::DrawCell(DrawingSurface *ds, ObjectPosition *eye,
									  int mapx, int mapy, int row, int col) {
	if (mapx < 0 || mapx >= CLevel.MapWidth || mapy < 0 || mapy >= CLevel.MapHeight) {
		return;
	}
	// +1 extra cell row, because we draw front walls of the far row
	if (row < 0 || row >= CV_Schema.CellRowCount + 1 ||
		col < 0 || col >= CV_Schema.CellColCount) {
		return;
	}
	
	int color_wall_1 = CLevel.BasicColor1[0]; // fixme
	int color_wall_2 = CLevel.BasicColor2[0];
	
	char type = CLevel.CellPassable[mapy * CLevel.MapWidth + mapx];
	if (type == 0) {
		// Draw floor and ceiling
		// --- skip for now ---
	} else {
		// Draw cell walls
		// cell lies in between the frame lines, so convert to vertex row/cols
		int frame_front_row = row;
		int frame_back_row = row + 1;
		int frame_left_col = col;
		int frame_right_col = col + 1;

		int front_x1 = CV_Schema.Strips[frame_front_row].X[frame_left_col];
		int front_x2 = CV_Schema.Strips[frame_front_row].X[frame_right_col];
		int front_y1 = CV_Schema.Strips[frame_front_row].Y1;
		int front_y2 = CV_Schema.Strips[frame_front_row].Y2;
		
		// Draw front wall, unless it's a base row
		if (row != 0) {
			ds.DrawQuadSplit(
				front_x1, front_y1, front_x2, front_y1,
				front_x2, front_y2, front_x1, front_y2, 
				color_wall_1, color_wall_2);
		}
		
		// Far row: only draw front wall, skip sides
		if (row == CV_Schema.CellRowCount) {
			return;
		}
		
		if (col < CV_Schema.CellColMiddle) {
			// Draw right wall
			int side_x1 = front_x2;
			int side_x2 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
			int side_y11 = front_y1;
			int side_y12 = front_y2;
			int side_y21 = CV_Schema.Strips[frame_back_row].Y1;
			int side_y22 = CV_Schema.Strips[frame_back_row].Y2;
			ds.DrawQuadSplit(
				side_x1, side_y11, side_x2, side_y21,
				side_x2, side_y22, side_x1, side_y12, 
				color_wall_1, color_wall_2);
		} else if (col > CV_Schema.CellColMiddle) {
			// Draw left wall
			int side_x1 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
			int side_x2 = front_x1;
			int side_y11 = CV_Schema.Strips[frame_back_row].Y1;
			int side_y12 = CV_Schema.Strips[frame_back_row].Y2;
			int side_y21 = front_y1;
			int side_y22 = front_y2;
			ds.DrawQuadSplit(
				side_x1, side_y11, side_x2, side_y21,
				side_x2, side_y22, side_x1, side_y12, 
				color_wall_1, color_wall_2);
		}
	}
}

static void FirstPersonView::GenerateAssetsForLevel() {
	FirstPersonView.ResetTileCache();
	// Generate wall sprites required for the "colored textures"
	readonly int gen_tex_num = (CLevel.TexColor1 != null) ?
		CLevel.TexColor1.Length : 0;

	// +1 extra cell row, because we draw front walls of the far row
	for (int row = 0; row < CV_Schema.CellRowCount + 1; ++row) {
		for (int col = 0; col < CV_Schema.CellColCount; ++col) {
			for (int tile = 0; tile < eCVTile_Object; ++tile) {
				TileTextures *tt = new TileTextures;
				tt.Base = FirstPersonView.CreateWallSprite(row, col, tile, -1);
				if (gen_tex_num > 0) {
					tt.Textures = new DynamicSprite[gen_tex_num];
					for (int tex_id = 0; tex_id < gen_tex_num; ++tex_id) {
						tt.Textures[tex_id] = FirstPersonView.CreateWallSprite(row, col, tile, tex_id);
					}
				}
				FPV.SprWalls[row, col, tile] = tt;
			}
		}
	}
}

static void FirstPersonView::SetCameraOffset(int camx, int camy) {
	FPV.CameraX = camx;
	FPV.CameraY = camy;
}

static void FirstPersonView::ConstructLocation(ObjectPosition *eye) {
	if (CV_Schema.CellRowCount == 0 || CV_Schema.CellColCount == 0) {
		return;
	}

	// +1 extra cell row, because we draw front walls of the far row
	readonly int num_rows = CV_Schema.CellRowCount + 1;
	readonly int num_cols = CV_Schema.CellColCount;
	readonly int mid = CV_Schema.CellColMiddle;

	// Prepare the transform axes.
	MapTransform *t = Level.GetObjectToMapTransform(eye);
	// Look around the map cells and draw what can be seen;
	// we start from the further row and come closer, far sides first.
	for (int row = num_rows - 1; row >= 0; --row) {
		// Draw columns in following order: first side columns from left and
		// right coming to the middle step by step, and then finally the middle one.
		for (int col = 0; col < mid; col++) {
			//System.Log(eLogDebug, "ConstructLocation: row %d col %d (%d)", row, col, num_cols - col - 1);
			FirstPersonView.ConstructCell(eye,
				t.originX + row * t.viewRowAxisX + (col - mid) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (col - mid) * t.viewColAxisY,
				row, col);
			FirstPersonView.ConstructCell(eye,
				t.originX + row * t.viewRowAxisX + (mid - col) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (mid - col) * t.viewColAxisY,
				row, num_cols - col - 1);
		}
		//System.Log(eLogDebug, "ConstructLocation: row %d col %d", row, mid);
		FirstPersonView.ConstructCell(eye,
			t.originX + row * t.viewRowAxisX + 0 * t.viewColAxisX,
			t.originY + row * t.viewRowAxisY + 0 * t.viewColAxisY,
			row, mid);
	}
}

static void FirstPersonView::ConstructCell(ObjectPosition *eye,
			int mapx, int mapy, int row, int col) {
	if (mapx < 0 || mapx >= CLevel.MapWidth || mapy < 0 || mapy >= CLevel.MapHeight ||
			// +1 extra cell row, because we draw front walls of the far row
			row < 0 || row >= CV_Schema.CellRowCount + 1 ||
			col < 0 || col >= CV_Schema.CellColCount) {
		FirstPersonView.HideWallTile(row, col, eCVTile_Ceil);
		FirstPersonView.HideWallTile(row, col, eCVTile_Floor);
		FirstPersonView.HideWallTile(row, col, eCVTile_Front);
		FirstPersonView.HideWallTile(row, col, eCVTile_Side);
		return;
	}

	int cell_index = mapy * CLevel.MapWidth + mapx;
	char type = CLevel.CellPassable[cell_index];
	if (type == 0) {
		// Draw floor and ceiling, unless it's a far row
		if (row != CV_Schema.CellRowCount) {
			FirstPersonView.DisplayWallTile(row, col, eCVTile_Ceil, CLevel.CeilTile[cell_index]);
			FirstPersonView.DisplayWallTile(row, col, eCVTile_Floor, CLevel.FloorTile[cell_index]);
		}
		// Hide walls
		FirstPersonView.HideWallTile(row, col, eCVTile_Front);
		FirstPersonView.HideWallTile(row, col, eCVTile_Side);
	} else {
		// Draw cell walls
		// Draw front wall, unless it's a base row
		if (row != 0) {
			FirstPersonView.DisplayWallTile(row, col, eCVTile_Front);
		}
		// Draw side wall, unless it's a far row, or middle columns
		if (row != CV_Schema.CellRowCount && col != CV_Schema.CellColMiddle) {
			FirstPersonView.DisplayWallTile(row, col, eCVTile_Side);
		}
		// Hide flat tiles
		FirstPersonView.HideWallTile(row, col, eCVTile_Ceil);
		FirstPersonView.HideWallTile(row, col, eCVTile_Floor);
	}
}

protected static DynamicSprite *FirstPersonView::CreateWallSprite(int row, int col,
		CellViewTile tile, int tex_id) {

	// Only draw front walls for far cell row
	if (row == CV_Schema.CellRowCount && tile != eCVTile_Front) {
		return null;
	}

	// Calculate wall quad from the cell position
	int frame_front_row = row;
	int frame_back_row = row + 1;
	int frame_left_col = col;
	int frame_right_col = col + 1;
	int front_x1 = CV_Schema.Strips[frame_front_row].X[frame_left_col];
	int front_x2 = CV_Schema.Strips[frame_front_row].X[frame_right_col];
	int front_y1 = CV_Schema.Strips[frame_front_row].Y1;
	int front_y2 = CV_Schema.Strips[frame_front_row].Y2;

	// xy11 - xy21
	// |         |
	// xy12 - xy22
	int x11, x12, x21, x22, y11, y12, y21, y22;
	bool vertical_wall = false;
	switch (tile) {
	case eCVTile_Floor:
		x11 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
		x12 = front_x1;
		x21 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
		x22 = front_x2;
		y11 = CV_Schema.Strips[frame_back_row].Y2;
		y21 = CV_Schema.Strips[frame_back_row].Y2;
		y12 = front_y2;
		y22 = front_y2;
		break;
	case eCVTile_Ceil:
		x11 = front_x1;
		x12 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
		x21 = front_x2;
		x22 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
		y11 = front_y1;
		y21 = front_y1;
		y12 = CV_Schema.Strips[frame_back_row].Y1;
		y22 = CV_Schema.Strips[frame_back_row].Y1;
		break;
	case eCVTile_Front:
		x11 = front_x1; x12 = x11;
		x21 = front_x2; x22 = x21;
		y11 = front_y1;
		y21 = front_y1;
		y12 = front_y2;
		y22 = front_y2;
		vertical_wall = true;
		break;
	case eCVTile_Side:
		if (col < CV_Schema.CellColMiddle) { // is a right wall
			x11 = front_x2; x12 = front_x2;
			x21 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
			x22 = x21;
			y11 = front_y1;
			y12 = front_y2;
			y21 = CV_Schema.Strips[frame_back_row].Y1;
			y22 = CV_Schema.Strips[frame_back_row].Y2;
		} else {
			x11 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
			x12 = x11;
			x21 = front_x1; x22 = x21;
			y11 = CV_Schema.Strips[frame_back_row].Y1;
			y12 = CV_Schema.Strips[frame_back_row].Y2;
			y21 = front_y1;
			y22 = front_y2;
		}
		vertical_wall = true;
		break;
	default: break;
	}

	if (vertical_wall && FPV.HalfWallMode) {
		y11 = y11 + (y12 - y11) / 2;
		y21 = y21 + (y22 - y21) / 2;
	}

	int x_min = Maths.Min(x11, x12);
	int x_max = Maths.Max(x21, x22);
	int y_min = Maths.Min(y11, y21);
	int x_width = x_max - x_min;
	int y_height = Maths.Max(y12 - y11, y22 - y21);
	int draw_color1 = (tex_id < 0) ? CLevel.BasicColor1[tile] : CLevel.TexColor1[tex_id];
	int draw_color2 = (tex_id < 0) ? CLevel.BasicColor2[tile] : CLevel.TexColor2[tex_id];
	DynamicSprite *dspr = DynamicSprite.Create(x_width, y_height);
	DrawingSurface *ds = dspr.GetDrawingSurface();
	ds.DrawQuadSplit(
				x11 - x_min, y11 - y_min, x21 - x_min, y21 - y_min,
				x22 - x_min, y22 - y_min, x12 - x_min, y12 - y_min, 
				draw_color1, draw_color2);
	ds.Release();
	return dspr;
}

protected static void FirstPersonView::CreateWallTile(int row, int col, CellViewTile tile) {
	readonly bool is_right_wall = col < CV_Schema.CellColMiddle;
	
	int x, y;
	switch (tile) {
	case eCVTile_Floor:
		x = Maths.Min(CV_Schema.Strips[row].X[col], CV_Schema.Strips[row + 1].X[col]);
		y = CV_Schema.Strips[row + 1].Y2;
		break;
	case eCVTile_Ceil:
		x = Maths.Min(CV_Schema.Strips[row].X[col], CV_Schema.Strips[row + 1].X[col]);
		y = CV_Schema.Strips[row].Y1;
		break;
	case eCVTile_Front:
		x = CV_Schema.Strips[row].X[col];
		y = CV_Schema.Strips[row].Y1;
		break;
	case eCVTile_Side:
		if (is_right_wall) {
			x = CV_Schema.Strips[row].X[col + 1];
			y = CV_Schema.Strips[row].Y1;
		} else {
			x = CV_Schema.Strips[row + 1].X[col];
			y = CV_Schema.Strips[row].Y1;
		}
		break;
	default: break;
	}
	
	Overlay *new_over = Overlay.CreateRoomGraphical(x, y, 0);
	new_over.ZOrder = FirstPersonView.CalcZorder(row, col, tile);
	WallTile *wall = new WallTile;
	wall.Over = new_over;
	wall.TexID = -2; // unassigned
	wall.BaseX = x;
	wall.BaseY = y;
	FPV.OverWalls[row, col, tile] = wall;
}

protected static void FirstPersonView::DisplayWallTile(int row, int col,
			CellViewTile tile, int tex_id) {
	if (FPV.OverWalls[row, col, tile] == null) {
		FirstPersonView.CreateWallTile(row, col, tile);	
	}
	
	WallTile *wall = FPV.OverWalls[row, col, tile];
	// Apply the proper texture
	if (wall.TexID != tex_id) {
		//System.Log(eLogDebug, "Get texture for row %d, col %d, tile %d, tex_id %d", row, col, tile, tex_id);
		TileTextures *txs = FPV.SprWalls[row, col, tile];
		DynamicSprite *dspr = (tex_id >= 0) ? txs.Textures[tex_id] : txs.Base;
		wall.Over.Graphic = dspr.Graphic;
		wall.TexID = tex_id;
	}

	// Adjust pos if necessary
	int x = wall.BaseX + FPV.CameraX;
	int y = wall.BaseY + FPV.CameraY;
	if (tile != eCVTile_Floor && tile != eCVTile_Ceil && FPV.HalfWallMode) {
		y += Game.SpriteHeight[wall.Over.Graphic];
	}
	wall.Over.X = x;
	wall.Over.Y = y;
	wall.Over.Transparency = 0; // make visible
}

protected static void FirstPersonView::HideWallTile(int row, int col, CellViewTile tile) {
	WallTile *wall = FPV.OverWalls[row, col, tile];
	if (wall != null) {
		wall.Over.Transparency = 100;
	}
}

static void FirstPersonView::ConstructObject(ObjectPosition *eye, ObjectPosition *obj, 
		int view, int loop, int frame, Overlay *over) {

	// First convert absolute object's coordinates into the player view's
	// coordinates. This is done through 2 transformations:
	// * map         -> player's local space (relative to player)
	// * local space -> cell view space (view row/col values)
	Point objlocpt = CLevel.MapToObject(eye, obj.X, obj.Y);
	Point cvpt = CV_Schema.ObjectToCellView(objlocpt.x, objlocpt.y);
	int col = cvpt.x;
	int row = cvpt.y;
	//
	//System.Log(eLogDebug, "ConstructObject: local to cellview: obj = %d,%d", 
	//	col, row);
	if (row < 0 || row >= CV_Schema.CellRowCount ||
		col < 0 || col >= CV_Schema.CellColCount) {
		// not in visible range
		//System.Log(eLogDebug, "ConstructObject: not in visible range");
		over.Transparency = 100;
		return;
	}

	// Object is located in the middle of a cell, in between the grid lines
	int frame_front_row = row;
	int frame_back_row = row + 1;
	int frame_left_col = col;
	int frame_right_col = col + 1;
	
	//System.Log(eLogDebug, "ConstructObject: frame lines: front %d,%d -> back %d,%d", 
	//	frame_front_row, frame_back_row, frame_left_col, frame_right_col);
	
	// Now when we know that we're going to place it on screen, let's set up a
	// proper graphic. Calculate which loop to use, depending on the RELATIVE
	// direction of the object's facing.
	ObjectDirection rel_dir = Level.MapToObjectDir(eye, obj.Dir);
	int use_loop = Level.DirToAGSLoop(rel_dir);
	//System.Log(eLogDebug, "ConstructObject: eyedir = %d, objdir = %d, rel_dir = %d, agsloop = %d", eye.Dir, obj.Dir, rel_dir, use_loop);
	ViewFrame *vf = Game.GetViewFrame(view, use_loop, frame);
	if (over.Graphic != vf.Graphic) {
		over.Graphic = vf.Graphic;
	}
	
	int y1 = CV_Schema.Strips[frame_back_row].Y2;
	int y2 = CV_Schema.Strips[frame_front_row].Y2;
	int x11 = CV_Schema.Strips[frame_front_row].X[frame_left_col];
	int x12 = CV_Schema.Strips[frame_front_row].X[frame_right_col];
	int x21 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
	int x22 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
	int x1 = (x11 + x12) / 2;
	int x2 = (x21 + x22) / 2;
	//System.Log(eLogDebug, "ConstructObject: x1,x2 = %d,%d", x1, x2);
	
	//System.Log(eLogDebug, "ConstructObject: pre scale w,h = %d,%d", over.Width, over.Height);
	float scaling = CV_Schema.CellScaling[row, col];
	over.Width = FloatToInt(IntToFloat(over.GraphicWidth) * scaling);
	over.Height = FloatToInt(IntToFloat(over.GraphicHeight) * scaling);
	//System.Log(eLogDebug, "ConstructObject: scaling = %f, w,h = %d,%d", scaling, over.Width, over.Height);
	int x = (x1 + x2) / 2 + FPV.CameraX - over.Width / 2;
	int y = (y1 + y2) / 2 + FPV.CameraY - over.Height;
	over.X = x;
	over.Y = y;
	over.ZOrder = FirstPersonView.CalcZorder(row, col, eCVTile_Object);
	over.Transparency = 0;
}

protected static int FirstPersonView::CalcZorder(int row, int col, CellViewTile tile) {
	int mid = CV_Schema.CellColMiddle;
	// z-order is increasing from far sides to the front center
	int effective_col = col <= mid ? col : (mid - (col - mid));
	// +1 extra cell row, because we draw front walls of the far row
	return ((CV_Schema.CellRowCount + 1 - row) * mid + effective_col) * eCVTileNum
		+ FPV.TileZorders[tile];
}


function game_start() {
	FPV.TileZorders[eCVTile_Floor]	= 0;
	FPV.TileZorders[eCVTile_Ceil]	= 1;
	FPV.TileZorders[eCVTile_Object]	= 2;
	FPV.TileZorders[eCVTile_Side]	= 3;
	FPV.TileZorders[eCVTile_Front]	= 4;
}
