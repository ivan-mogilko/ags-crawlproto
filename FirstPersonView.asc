
void CellViewSchema::SetView(int width, int height, int row_count, int col_count) {
	if (row_count > CELLVIEW_MAX_ROWS || col_count > CELLVIEW_MAX_COLS) {
		return;
	}

	Width = width;
	Height = height;
	RowCount = row_count;
	ColCount = col_count;
}

void CellViewSchema::SetUniformStrip(int row, int y1, int y2, int x_start, int u_width) {
	if (row < 0 || row >= RowCount) {
		return;
	}

	Strips[row].Y1 = y1;
	Strips[row].Y2 = y2;
	for (int col = 0; col < ColCount; ++col) {
		Strips[row].X[col] = x_start + u_width * col;
	}
}

CellViewSchema CV_Schema;
export CV_Schema;


static void FirstPersonView::DrawViewport(DrawingSurface* ds, int color) {
	ds.DrawingColor = color;
	ds.DrawFrame(0, 0, CV_Schema.Width - 1, CV_Schema.Height - 1);
}

static void FirstPersonView::DrawGridFrame(DrawingSurface* ds, int cell_color, int wall_color) {
	if (cell_color > 0) {
		ds.DrawingColor = cell_color;
		// NOTE: we assume that row 0 is "behind" the player's back, so invisible
		// horizontal lines (cells fronts)
		for (int row = 1; row < CV_Schema.RowCount; ++row) {
			for (int col = 0; col < CV_Schema.ColCount - 1; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row].X[col + 1], 
							CV_Schema.Strips[row].Y1);
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2, 
							CV_Schema.Strips[row].X[col + 1], 
							CV_Schema.Strips[row].Y2);
			}
		}
		
		// directional lines (cell sides)
		for (int row = 0; row < CV_Schema.RowCount - 1; ++row) {
			for (int col = 0; col < CV_Schema.ColCount; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row + 1].X[col], 
							CV_Schema.Strips[row + 1].Y1);
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2, 
							CV_Schema.Strips[row + 1].X[col], 
							CV_Schema.Strips[row + 1].Y2);
			}
		}
	}
	
	if (wall_color > 0) {
		ds.DrawingColor = wall_color;
		for (int row = 0; row < CV_Schema.RowCount; ++row) {
			for (int col = 0; col < CV_Schema.ColCount; ++col) {
				ds.DrawLine(CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y1, 
							CV_Schema.Strips[row].X[col], 
							CV_Schema.Strips[row].Y2);
			}
		}
	}
}

// Draws particular map cell in viewport
static void FirstPersonView::DrawCell(DrawingSurface *ds, WorldPosition *eye,
									  int mapx, int mapy, int row, int col) {
	if (mapx < 0 || mapx >= CLevel.MapWidth || mapy < 0 || mapy >= CLevel.MapHeight) {
		return;
	}
	
	readonly int colMiddle = (CV_Schema.ColCount - 1) / 2;
	readonly int color_wall_1 = 7;
	readonly int color_wall_2 = 8;
	
	char type = CLevel.CellPassable[mapy * CLevel.MapWidth + mapx];
	if (type == 0) {
		// Draw floor and ceiling
		// --- skip for now ---
	} else {
		// Draw cell walls
		// cell lies in between the frame lines
		int frame_front_row = row;
		int frame_back_row = row + 1;
		int frame_left_col = col;
		int frame_right_col = col + 1;

		// Draw front wall always
		int front_x1 = CV_Schema.Strips[frame_front_row].X[frame_left_col];
		int front_x2 = CV_Schema.Strips[frame_front_row].X[frame_right_col];
		int front_y1 = CV_Schema.Strips[frame_front_row].Y1;
		int front_y2 = CV_Schema.Strips[frame_front_row].Y2;
		ds.DrawQuadSplit(
			front_x1, front_y1, front_x2, front_y1,
			front_x2, front_y2, front_x1, front_y2, 
			color_wall_1, color_wall_2);
		
		// Far row: only draw front wall
		if (frame_back_row == CV_Schema.RowCount) {
			return;
		}
		
		if (col < colMiddle) {
			// Draw right wall
			int side_x1 = front_x2;
			int side_x2 = CV_Schema.Strips[frame_back_row].X[frame_right_col];
			int side_y11 = front_y1;
			int side_y12 = front_y2;
			int side_y21 = CV_Schema.Strips[frame_back_row].Y1;
			int side_y22 = CV_Schema.Strips[frame_back_row].Y2;
			ds.DrawQuadSplit(
				side_x1, side_y11, side_x2, side_y21,
				side_x2, side_y22, side_x1, side_y12, 
				color_wall_1, color_wall_2);
		} else if (col > colMiddle) {
			// Draw left wall
			int side_x1 = CV_Schema.Strips[frame_back_row].X[frame_left_col];
			int side_x2 = front_x1;
			int side_y11 = CV_Schema.Strips[frame_back_row].Y1;
			int side_y12 = CV_Schema.Strips[frame_back_row].Y2;
			int side_y21 = front_y1;
			int side_y22 = front_y2;
			ds.DrawQuadSplit(
				side_x1, side_y11, side_x2, side_y21,
				side_x2, side_y22, side_x1, side_y12, 
				color_wall_1, color_wall_2);
		}
	}
}

// Draws current view as seen from the given cell into given direction
static void FirstPersonView::DrawLocation(DrawingSurface *ds, WorldPosition *eye) {
	// Convert from the grid row/col count to inner cell count
	// FIXME?
	readonly int num_rows = CV_Schema.RowCount /*- 1*/;
	readonly int num_cols = CV_Schema.ColCount - 1;
	if (num_rows == 0 || num_cols == 0) {
		return;
	}

	readonly int colMiddle = num_cols / 2;

	// Prepare the transform axes.
	MapTransform *t = Location.GetObjectToMapTransform(eye);
	// Look around the map cells and draw what can be seen;
	// we start from the further row and come closer, far sides first.
	for (int row = num_rows; row > 0;) {
		row--;

		// Draw columns in following order: first side columns from left and
		// right coming to the middle step by step, and then finally the middle one.
		for (int col = 0; col < colMiddle; col++) {
			FirstPersonView.DrawCell(ds, eye,
				t.originX + row * t.viewRowAxisX + (col - colMiddle) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (col - colMiddle) * t.viewColAxisY,
				row, col);
			FirstPersonView.DrawCell(ds, eye,
				t.originX + row * t.viewRowAxisX + (colMiddle - col) * t.viewColAxisX,
				t.originY + row * t.viewRowAxisY + (colMiddle - col) * t.viewColAxisY,
				row, num_cols - col - 1);
		}
		FirstPersonView.DrawCell(ds, eye,
			t.originX + row * t.viewRowAxisX + 0 * t.viewColAxisX,
			t.originY + row * t.viewRowAxisY + 0 * t.viewColAxisY,
			row, colMiddle);
	}
}
