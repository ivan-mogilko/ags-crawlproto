
DynamicSprite *SprFPV;
ObjectPosition *playerEye;
export playerEye;
WoodRotAI *Mobs[];

static void WoodRotGame::DrawGrid(DrawingSurface *dest, int x, int y, int w, int h) {
	DrawingSurface *ds = SprFPV.GetDrawingSurface();
	FirstPersonView.DrawGridFrame(ds, 12, 14);
	FirstPersonView.DrawViewport(ds, 15);
	ds.Release();
	dest.DrawImage(x, y, SprFPV.Graphic);
}

static void WoodRotGame::DrawPlayerView(DrawingSurface *dest, int x, int y, int w, int h) {
	// FIXME: there's no need to reconstruct whole view on each tick, 
	// separate to reconstruct whole, and mobs only
	DrawingSurface *ds = SprFPV.GetDrawingSurface();
	ds.Clear(0);
	FirstPersonView.DrawGridFrame(ds, 12, 14);
	//FirstPersonView.DrawLocation(ds, playerEye);
	//FirstPersonView.DrawViewport(ds, 15);
	ds.Release();
	dest.DrawImage(x, y, SprFPV.Graphic);
	
	FirstPersonView.SetCameraOffset(x, y);
	FirstPersonView.ConstructLocation(playerEye);
	for (int i = 0; i < Mobs.Length; ++i) {
		FirstPersonView.ConstructObject(playerEye, Mobs[i].Pos,
			Mobs[i].Runner.View, Mobs[i].Runner.Loop, Mobs[i].Runner.Frame, 
			Mobs[i].Over);
	}
}

static bool WoodRotGame::TryWalkLocal(ObjectPosition *who, int dx, int dy) {
	Point *ptoff = Level.ObjectDeltaToMap(who, dx, dy);
	return WoodRotGame.TryWalkAbs(who, ptoff.x, ptoff.y);
}
	
static bool WoodRotGame::TryWalkAbs(ObjectPosition *who, int dx, int dy) {
	int final_x = who.X + dx;
	int final_y = who.Y + dy;
	readonly int ddx = Maths.Sign(dx);
	readonly int ddy = Maths.Sign(dy);
	
	//System.Log(eLogDebug, "who = %d,%d, final = %d,%d, ddx = %d,%d", who.X, who.Y, final_x, final_y, ddx, ddy);
	
	while (who.X != final_x || who.Y != final_y) {
		int test_x = who.X + ddx;
		int test_y = who.Y + ddy;
		//System.Log(eLogDebug, "test = %d,%d", test_x, test_y);
		if (test_x < 0 || test_x >= CLevel.MapWidth ||
			test_y < 0 || test_y >= CLevel.MapHeight) {
			//System.Log(eLogDebug, "out of bounds");
			return false;
		}
		// TODO: test passability bits
		if (CLevel.CellPassable[test_y * CLevel.MapWidth + test_x] > 0) {
			//System.Log(eLogDebug, "impassable");
			return false;
		}
		who.X = test_x;
		who.Y = test_y;
	}
	//System.Log(eLogDebug, "success");
	return true;
}

static ObjectDirection WoodRotGame::Turn(ObjectPosition *who, bool clockwise) {
	int dir = clockwise ? who.Dir + 1 : who.Dir - 1;
	if (dir < eDirNorth) {
		dir = eDirWest;
	} else if (dir > eDirWest) {
		dir = eDirNorth;
	}
	who.Dir = dir;
	return dir;
}

static ObjectDirection WoodRotGame::Face(ObjectPosition *who, ObjectDirection dir) {
	who.Dir = dir;
	return dir;
}

static ObjectDirection WoodRotGame::FaceDeltaPos(ObjectPosition *who, int dx, int dy) {
	if (dx > 0) {
		return WoodRotGame.Face(who, eDirEast);
	} else if (dx < 0) {
		return WoodRotGame.Face(who, eDirWest);
	} else if (dy > 0) {
		return WoodRotGame.Face(who, eDirSouth);
	} else {
		return WoodRotGame.Face(who, eDirNorth);
	}
}

static void WoodRotGame::AddAI(WoodRotAI *ai) {
	if (Mobs == null) {
		Mobs = new WoodRotAI[1];
	} else {
		int old_len = Mobs.Length;
		WoodRotAI *new_mobs[] = new WoodRotAI[old_len + 1];
		for (int i = 0; i < old_len; ++i) {
			new_mobs[i] = Mobs[i];
		}
		Mobs = new_mobs;
	}
	Mobs[Mobs.Length - 1] = ai;
}

static void WoodRotGame::TickAI() {
	for (int i = 0; i < Mobs.Length; ++i) {
		Mobs[i].Tick();
	}
}

static WoodRotAI *WoodRotAI::Create(DSM_StateList *list, ObjectPosition *pos) {
	// fixme position in the world
	WoodRotAI *ai = new WoodRotAI;
	ai.Runner = DSM_StateRunner.Create(list);
	ai.Over = Overlay.CreateRoomGraphical(0, 0, 0);
	ai.Pos = pos;
	ai.Tick(); // fixme, need to start somewhere
	return ai;
}

void WoodRotAI::Tick() {
	String action = Runner.Tick();
	if (Runner.Frame >= 0) {
		// We are doing a directional loop draw in FirstPersonView
	}
	if (!String.IsNullOrEmpty(action)) {
		Action(action);
	}
}

void WoodRotAI::Action(String action) {
	if (action.CompareTo("A_Decide") == 0) {
		int rand = Random(2);
		switch (rand) {
		case 0: Runner.Goto("Idle"); break;
		case 1: Runner.Goto("Walk"); break;
		case 2: Runner.Goto("Speak"); break;
		default: break;
		}
	} else if (action.CompareTo("A_Step") == 0) {
		if (WalkTarget == null) {
			WalkTarget = ObjectPosition.Create(
				Random(CLevel.MapWidth - 1), 
				Random(CLevel.MapHeight - 1), 
				eDirNorth + Random(eDirWest - eDirNorth));
			//System.Log(eLogDebug, "AI: new WalkTarget = %d,%d", WalkTarget.X, WalkTarget.Y);
		}

		//System.Log(eLogDebug, "AI: at %d,%d, WT = %d,%d", Pos.X, Pos.Y, WalkTarget.X, WalkTarget.Y);
		if (WalkTarget.X == Pos.X && WalkTarget.Y == Pos.Y) {
			//System.Log(eLogDebug, "AI: reached the WT");
			WalkTarget = null;
			return;
		}

		int dx = Maths.Sign(WalkTarget.X - Pos.X);
		int dy = Maths.Sign(WalkTarget.Y - Pos.Y);
		//System.Log(eLogDebug, "AI: try walk dx,dy = %d,%d", dx, dy);
		// FIXME: passability bit check
		dx = dx * !CLevel.CellPassable[Pos.Y * CLevel.MapWidth + Pos.X + dx];
		dy = dy * !CLevel.CellPassable[(Pos.Y + dy) * CLevel.MapWidth + Pos.X];
		bool res;
		if (dx != 0 && (dy == 0 || Random(1) == 0)) {
			WoodRotGame.FaceDeltaPos(Pos, dx, 0);
			res = WoodRotGame.TryWalkAbs(Pos, dx, 0);
			//System.Log(eLogDebug, "AI: dx failed");
		}
		if (dy != 0 && !res) {
			WoodRotGame.FaceDeltaPos(Pos, 0, dy);
			res = WoodRotGame.TryWalkAbs(Pos, 0, dy);
			//System.Log(eLogDebug, "AI: dy failed");
		}
		if (!res) {
			//System.Log(eLogDebug, "AI: failed, reset WT");
			WalkTarget = null;
			return;
		}
	} else if (action.CompareTo("A_Speak") == 0) {
	}
}


function game_start()
{
	CV_Schema.SetView(WoodRotConstants.VIEWPORT_WIDTH,
					  WoodRotConstants.VIEWPORT_HEIGHT,
					  WoodRotConstants.VIEW_ROWS,
					  WoodRotConstants.VIEW_COLS);
	CV_Schema.SetUniformStrip(0, -16, 187, -22 - 285*5, 285);
	CV_Schema.SetUniformStrip(1, 18, 156, 24 - 192*5 , 192);
	CV_Schema.SetUniformStrip(2, 41, 133, 58 - 127*5, 127);
	CV_Schema.SetUniformStrip(3, 58, 115, 81 - 81*5, 81);
	CV_Schema.SetUniformStrip(4, 70, 103, 98 - 47*5, 47);
	CV_Schema.SetUniformStrip(5, 79, 94, 110 - 23*5, 23);
	// NOTE: we do not alloc the last vertices strip for the farthest cell row, 
	// because we only want to draw front walls of that row

	CV_Schema.SetScaling(3.0, 0.65, 1.0);

	SprFPV = DynamicSprite.Create(WoodRotConstants.VIEWPORT_WIDTH, WoodRotConstants.VIEWPORT_HEIGHT);

	CLevel.BasicColor1[eTxType_Front] = Game.GetColorFromRGB(168, 168, 168);
	CLevel.BasicColor2[eTxType_Front] = Game.GetColorFromRGB(112, 112, 112);
	CLevel.BasicColor1[eTxType_Side] = Game.GetColorFromRGB(128, 128, 128);
	CLevel.BasicColor2[eTxType_Side] = Game.GetColorFromRGB(96, 96, 96);
	CLevel.BasicColor1[eTxType_Floor] = Game.GetColorFromRGB(128, 128, 64);
	CLevel.BasicColor2[eTxType_Floor] = Game.GetColorFromRGB(96, 96, 32);
	CLevel.BasicColor1[eTxType_Ceil] = Game.GetColorFromRGB(128, 128, 196);
	CLevel.BasicColor2[eTxType_Ceil] = Game.GetColorFromRGB(96, 96, 196);
	// FIXME: hide array allocations in the Level's function, make writeprotected?
	CLevel.MapWidth = 20;
	CLevel.MapHeight = 10;
	CLevel.CellPassable = new char[CLevel.MapWidth * CLevel.MapHeight];
	CLevel.CellTiles = new CellTile[CLevel.MapWidth * CLevel.MapHeight];
	const int num_textures = 2;
	CLevel.TexColor1 = new int[num_textures];
	CLevel.TexColor2 = new int[num_textures];
	CLevel.TexColor1[0] = Game.GetColorFromRGB(128, 64, 64);
	CLevel.TexColor2[0] = Game.GetColorFromRGB(96, 48, 48);
	CLevel.TexSeq = new TextureSequence[num_textures];
	TextureSequence txseq = new TextureSequence;
	txseq.Type = eTxSeq_Normal;
	txseq.TexColor1 = new int[4];
	txseq.TexColor2 = new int[4];
	for (int i = 0; i < 4; ++i) {
		txseq.TexColor1[i] = Game.GetColorFromRGB(32 + i * 16, 32 + i * 16, 192);
		txseq.TexColor2[i] = Game.GetColorFromRGB(32 + i * 8, 32 + i * 8, 168);
	}
	txseq.FrameTime = 16;
	CLevel.TexSeq[1] = txseq;
	String mappass = ""
	/**/
		"11111111111111111111"
		"10000000011000000001"
		"10101010011000000001"
		"10101011011000000001"
		"10100000000000000001"
		"10101011011000000001"
		"10101010011000000001"
		"10111011011000000001"
		"10000000011000000001"
		"11111111111111111111"
		/**/
		/*
		"1111111111"
		"1000000001"
		"1000000001"
		"1000000001"
		"1000000001"
		"1000000001"
		"1000000001"
		"1000000001"
		"1000000001"
		"1111111111"
		/**/
		;
	String mapfloor = ""
		"////////////////////"
		"/0///0//0///////////"
		"////////////////////"
		"/////////////1111///"
		"/////////////1111///"
		"/////////////1111///"
		"/////////////1111///"
		"////////////////////"
		"/0///0//0///////////"
		"////////////////////"
		;
	String mapfloorframe = ""
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"/////////////0123///"
		"/////////////1123///"
		"/////////////2223///"
		"/////////////3333///"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		;
	String mapceil = ""
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		"////////////////////"
		;
	for (int i = 0; i < mappass.Length; ++i) {
		CLevel.CellPassable[i] = mappass.Chars[i] - '0';
		CLevel.CellTiles[i] = new CellTile;
		CLevel.CellTiles[i].FloorTile = mapfloor.Chars[i] - '0';
		CLevel.CellTiles[i].FloorFrame = mapfloorframe.Chars[i] - '0';
		CLevel.CellTiles[i].CeilTile = mapceil.Chars[i] - '0';
	}

	String mob_ai = ""
	/* ---- NOT WORKING AND NOT ENOUGH SPARE TIME TO FIX ----
		"STATE Idle                        \n"
		"    LOOP 0 0,1 4                  \n"
		"    LOOP 0 0 4 A_Decide 0.1       \n"
		"    GOTO 1 Idle                   \n"
		"STATE Walk                        \n"
		"    LOOP 0 0,1,2, 4               \n"
		"    LOOP 0 3 4 A_Step 1           \n"
		"    LOOP 0 4,5,6 4                \n"
		"    GOTO 0.05 Idle                \n"
		"    GOTO 1 Walk                   \n"
		"STATE Speak                       \n"
		"    LOOP 0 0,1 4                  \n"
		"    GOTO 1 Idle                   \n"
		*/
		"STATE Walk                        \n"
		"    LOOP 0 0,1,2, 4               \n"
		"    LOOP 0 3 4 A_Step 1           \n"
		"    LOOP 0 4,5,6 4                \n"
		"    GOTO 1 Walk                   \n"
	;
	
	DSM_StateList *mob_list = DSM_StateList.CreateFromText(VDUMMYNPC1, mob_ai);
	
	WoodRotGame.AddAI(
		WoodRotAI.Create(mob_list, ObjectPosition.Create(1, 1, eDirEast)));
	WoodRotGame.AddAI(
		WoodRotAI.Create(mob_list, ObjectPosition.Create(8, 1, eDirWest)));
	WoodRotGame.AddAI(
		WoodRotAI.Create(mob_list, ObjectPosition.Create(1, 8, eDirEast)));
	WoodRotGame.AddAI(
		WoodRotAI.Create(mob_list, ObjectPosition.Create(8, 8, eDirEast)));
	playerEye = ObjectPosition.Create(5, 8, eDirNorth);

	FirstPersonView.SetHalfWallMode(true);
	FirstPersonView.GenerateAssetsForLevel();
}

function repeatedly_execute()
{
	Level.Tick();
	WoodRotGame.TickAI();
}

function on_event(EventType event, int data)
{
	if (event == eEventEnterRoomBeforeFadein) {
		// This is a to clip unnecessary wall bits seen at the screen sides;
		// TODO: correct the schema grid instead, and let FirstPersonView handle this?
		// FIXME: also, this should be in game start, but there seem to be a bug
		// in AGS, that resets camera after game start(?)
		Screen.AutoSizeViewportOnRoomLoad = false;
		Screen.Viewport.SetPosition((Screen.Width - 285) / 2, (Screen.Height - 204) / 2, 285, 204);
		Game.Camera.SetSize(285, 204);
	}
}
